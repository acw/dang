module ModuleSystem.Imports (
  -- * Usage Sets
    Use(..)
  , UseSet
  , UsesModules(getUses)

  , minimalImports
  ) where

import QualName (QualName,isSimpleName,qualModule)
import Syntax.AST
    (Module(..),Open(..),PrimType(..),PrimTerm(..),TypedDecl(..),UntypedDecl(..)
    ,DataDecl(..),Constr(..),Match(..),Pat(..),Term(..))
import TypeChecker.Types (Forall(..),forallData,Type(..))

import Control.Monad (guard)
import Data.List (foldl')
import Data.Maybe (fromMaybe)
import qualified Data.Set as Set


-- Usage Sets ------------------------------------------------------------------

data Use
  = Explicit Open     -- ^ Module use via an open declaration
  | Implicit QualName -- ^ Module use via a qualified name
    deriving (Eq,Show,Ord)

type UseSet = Set.Set Use

class UsesModules a where
  getUses :: a -> UseSet

instance UsesModules a => UsesModules (Maybe a) where
  getUses = maybe Set.empty getUses

instance UsesModules a => UsesModules [a] where
  getUses = Set.unions . map getUses

-- | The imports required by a module are those specified by its open
-- declarations, and implicit uses in terms or types.
instance UsesModules Module where
  getUses m = Set.unions
    [ getUses (modOpens m)
    , getUses (modTyped m)
    , getUses (modUntyped m)
    , getUses (modPrimTerms m)
    , getUses (modPrimTypes m)
    , getUses (modDatas m)
    ]

instance UsesModules Open where
  getUses = Set.singleton . Explicit

-- | Module uses from a typed declaration can arise from either its term or
-- type.  Union the two sets.
instance UsesModules TypedDecl where
  getUses td =
    getUses (typedType td) `Set.union` getUses (typedBody td)

-- | Module uses from an untyped declaration arise only from its body.
instance UsesModules UntypedDecl where
  getUses = getUses . untypedBody

-- | Module uses from a primitive term will only arise from its type schema.
instance UsesModules PrimTerm where
  getUses = getUses . primTermType

-- | Module uses from a primitive type will only arise from its kind.
instance UsesModules PrimType where
  getUses = getUses . primTypeKind

-- | Module uses from a data declaration are generated by the types referenced
-- in its constructors.
instance UsesModules DataDecl where
  getUses = getUses . dataConstrs

instance UsesModules Constr where
  getUses = getUses . constrParams

instance UsesModules a => UsesModules (Forall a) where
  getUses = getUses . forallData

-- | Module uses from a type arise from the name-space used on a constructor.
instance UsesModules Type where
  getUses ty = case ty of
    TApp f x      -> getUses f `Set.union` getUses x
    TInfix qn l r -> Set.unions [globalName qn, getUses l, getUses r]
    TCon qn       -> globalName qn
    TVar{}        -> Set.empty

instance UsesModules Match where
  getUses (MPat p m') = getUses p `Set.union` getUses m'
  getUses (MTerm tm)  = getUses tm

instance UsesModules Pat where
  getUses (PVar _)  = Set.empty
  getUses PWildcard = Set.empty

instance UsesModules Term where
  getUses tm = case tm of
    Abs m       -> getUses m
    Let ts us e -> Set.unions [getUses ts, getUses us, getUses e]
    App f xs    -> getUses f `Set.union` getUses xs
    Local _     -> Set.empty
    Global qn   -> globalName qn
    Lit _       -> Set.empty

-- | Generate the import set for a used name, if one exists.
globalName :: QualName -> UseSet
globalName qn = fromMaybe Set.empty $ do
  guard (not (isSimpleName qn))
  return (Set.singleton (Implicit qn))


-- Import Sets -----------------------------------------------------------------

type ImportSet = Set.Set QualName

-- | Given a set of module uses, calculate the minimal set of modules that are
-- required to satisfy the uses.
minimalImports :: UseSet -> ImportSet
minimalImports us = ms Set.\\ rs
  where
  (rs,ms)           = foldl' step (Set.empty,Set.empty) (Set.toList us)
  step st@(as,bs) u = case u of
    Explicit o -> ( maybe as (`Set.insert` as) (openAs o)
                  , Set.insert (openMod o) bs)
    Implicit n -> (as,maybe bs (`Set.insert` bs) (qualModule n))
